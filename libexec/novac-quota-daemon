#!/usr/bin/env ruby
$:.unshift File.expand_path("../../share/novac/lib/rb", __FILE__)
require 'rubygems'
require 'novadb2'
require 'helpers/quotas'
require 'logger'
require 'eventmachine'
require 'amqp'
require 'json'
require 'pp'

# Ensure root or sudo is used for this command
if Process.euid != 0
  throw "Must run this script as root or sudo."
end

# Create a logger
logger = Logger.new('/var/log/nova/quotas.log')

# Create the novadb object
novadb = NovaDB2.instance

# Create a quota object
quota = Quotas.new

# Array of events to monitor for
events = ['compute.instance.create.start', 'compute.instance.delete.end',
          'volume.create.start', 'volume.delete.end',
          'network.floating_ip.allocate', 'network.floating_ip.deallocate',
          'image.upload', 'image.delete', 'image.update']
#events = []

logger.info('Initialized OK')

# Handle errors
EventMachine.error_handler do |e|
  logger.error e.inspect
  logger.error e.backtrace.first
end

# Start the main event loop
# This reads in all available rabbitmq servers,
# connects to them, then monitors their monitor.*
# topic for certain events triggered by nova
begin
  EventMachine.run do
    logger.info('EventMachine started')
    novadb.regions.each do |region|
      queue_info = novadb.get_queue(region)['nova']
      conn = AMQP.connect(queue_info)
      ch   = AMQP::Channel.new(conn)
      ex   = ch.topic(queue_info[:topic])

      logger.info("Monitoring #{queue_info[:queue]} #{queue_info[:routing_key]} on #{region}")
      ch.queue(queue_info[:queue]).bind(ex, :routing_key => queue_info[:routing_key]).subscribe do |headers, payload|
        p = JSON.parse(payload)
        if p.has_key?('event_type')
          event = p['event_type']
          logger.info(event)
          if events.include?(event)
            logger.info("Caught event in #{region}: #{event}")
            if p.has_key?('payload')
              project_id = nil
              if p['payload'].has_key?('tenant_id')
                project_id = p['payload']['tenant_id']
              elsif p['payload'].has_key?('project_id')
                project_id = p['payload']['project_id']
              elsif p['payload'].has_key?('owner')
                project_id = p['payload']['owner']
              end
              if project_id
                logger.info("Balancing usage for #{project_id}")
                quota.balance_usage_for_project(project_id)
                logger.info("Done")
              end
            end
          end
        end
      end
    end
  end
rescue Exception => e
  logger.error(e)
end
